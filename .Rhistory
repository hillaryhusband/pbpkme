install.packages("devtools")
install.packages("roxygen2")
library(devtools)
install_github("devtools", "hadley")
load.all()
load_all()
library(pbpkme)
install.packages(Rtools)
install.packages("Rtools")
rate_coeff <- matrix(0, nrow = 2, ncol = 2)
init_condition <- matrix(1, nrow = 2, ncol = 1)
param <- data.frame(x = 4)
param
## needs
minute <- 160
h <- 0.05
rate_coeff <- matrix(0, nrow = 2, ncol = 2)
init_condition <- matrix(1, nrow = 2, ncol = 1)
number_of_doses <- 1 # default - 1
start_time <- matrix(0, nrow = 1, ncol = 1)
stop_time <- matrix(0, nrow = 1, ncol = 1)
rate_coeff[1,1] = 2*x
rate_coeff[2,1] = -1
rate_coeff[1,2] = 1
rate_coeff[2,2] = y^2
param <- data.frame(c((x = 4), (y = 2)))
rate_coeff[1,1] = 2*x
rate_coeff[2,1] = -1
rate_coeff[1,2] = 1
rate_coeff[2,2] = y^2
rate_coeff
pbpkme <- function(minute, h, rate_coeff, init_condition, param, number_of_doses, start_time, stop_time) {
t_index_max = (minute / h) + 1
tol_value = 10^-500
matrix_size = nrow(rate_coeff)
injection_rate <- matrix(0, nrow = t_index_max, ncol=1)
for (t_index in 1:t_index_max) {
t <- (t_index - 1) * h
for (i in 1:number_of_doses) {
if (t <= stop_time[i] && t > start_time[i]) {injection_rate[t_index,] <- dose[i] / (stop_time[i] - start_time[i])}
}
if (nrow(rate_coeff) != ncol(rate_coeff)) {
stop('matrix must be square')
}
if (nrow(rate_coeff) != nnrow(init_condition)) {
stop('initial conditions must be same size as rate coefficient matrix')
}
# eigenvalue/eigenvector solution
# eigenvalues and eigenvectors of coefficient matrix
eigen_matrix <- eigen(rate_coeff)
# print eigenvalues and eigenvectors
eigen_matrix$values
eigen_matrix$vectors
# separate real and imaginary parts of eigenvectors
a_real_eigenvec <- Re(eigen_matrix$vectors)
b_imag_eigenvec <- Im(eigen_matrix$vectors)
# print real and complex eigenvectors
a_real_eigenvec
b_imag_eigenvec
# separate real and imaginary parts of eigenvalues
lambda <- Re(eigen_matrix$values)
mu <- Im(eigen_matrix$values)
# print real and complex eigenvalues
lambda
mu
# initialize matrices
x_matrix_save <- vector()
u_matrix <- matrix(0, nrow = matrix_size, ncol = 1)
g_vector <- matrix(0, nrow = matrix_size, ncol = 1)
u_prime_matrix <- matrix()
u_prime_matrix_save <- matrix(0, nrow = matrix_size, ncol = 1)
fund_matrix <- matrix(0, nrow = matrix_size, ncol = matrix_size)
t = 0
## calculate fundamental matrix and inverse of fundamental matrix for 0, h, 2*h
while (t <= h*2) {
i <- 1
while (i <= matrix_size){
j <- 1
while (j <= matrix_size) {
if (mu[j] == 0) {
fund_matrix[i,j] <- exp(lambda[j]*t)*(a_real_eigenvec[i,j] * cos(mu[j]*t))
j <- j + 1
}
else {
fund_matrix[i,j] <- exp(lambda[j]*t) * (a_real_eigenvec[i,j] * cos(mu[j]*t) - b_imag_eigenvec[i,j] * sin(mu[j]*t))
j <- j + 1
fund_matrix[i,j] <- exp(lambda[j]*t) * (a_real_eigenvec[i,j] * sin(mu[j]*t) + b_imag_eigenvec[i,j] * cos(mu[j]*t))
j <- j + 1
}
}
i = i + 1
}
if (t == 0) {
t0_fund_matrix <- fund_matrix
} else if (t == h * 1) {
t1_fund_matrix <- fund_matrix
} else if (t == h * 2 ) {
t2_fund_matrix <- fund_matrix
} else {
fund_matrix <- fund_matrix
}
t = t + h
}
t0_inv_fund_matrix = solve(t0_fund_matrix, tol = tol_value)
t1_inv_fund_matrix = solve(t1_fund_matrix, tol = tol_value)
t2_inv_fund_matrix = solve(t2_fund_matrix, tol = tol_value)
## function starts here
for (t_index in seq(from = 1, to = t_index_max, by = 1)) {
g_vector[1,1] <- injection_rate[t_index]
u_prime_matrix0 <- t0_inv_fund_matrix %*% g_vector
u_prime_matrix1 <- t1_inv_fund_matrix %*% g_vector
u_prime_matrix2 <- t2_inv_fund_matrix %*% g_vector
## initial time,
## run once to get constant vector
t0_inv_fund_matrix = solve(t0_fund_matrix, tol = tol_value)
# constants for a given initial condition at t = 0
int_constants =   t0_inv_fund_matrix %*% init_condition
## Simpson's 1/3 rule for 0 to 0.2
sim_soln <- (h/3) * (u_prime_matrix0 + (4 * u_prime_matrix1) + u_prime_matrix2)
sim_soln <- matrix(sim_soln)
## u_matrix should be term by term u_prime_matrix integrated w.r.t. t and bounds 0 to time point
x_matrix = fund_matrix %*% int_constants + fund_matrix %*% sim_soln
x_matrix_save <- cbind(x_matrix_save, x_matrix)
## x_matrix solution becomes initial condition for next tau
init_condition = x_matrix
}
return(x_matrix_save)
}
}
rate_coeff1 <- matrix(0, nrow = 2, ncol = 2)
init_condition <- matrix(1, nrow = 2, ncol = 1)
param1 <- data.frame(c((x = 4), (y = 2)))
pbpkme(10, 0.1, rate_coeff1, init_condition1, param1, 1, 0,5)
pbpkme(10, 0.1, rate_coeff1, init_condition1, param1, 1, 0,5)
pbpkme <- function(minute, h, rate_coeff, init_condition, param, number_of_doses, start_time, stop_time) {
t_index_max = (minute / h) + 1
tol_value = 10^-500
matrix_size = nrow(rate_coeff)
injection_rate <- matrix(0, nrow = t_index_max, ncol=1)
for (t_index in 1:t_index_max) {
t <- (t_index - 1) * h
for (i in 1:number_of_doses) {
if (t <= stop_time[i] && t > start_time[i]) {injection_rate[t_index,] <- dose[i] / (stop_time[i] - start_time[i])}
}
if (nrow(rate_coeff) != ncol(rate_coeff)) {
stop('matrix must be square')
}
if (nrow(rate_coeff) != nrow(init_condition)) {
stop('initial conditions must be same size as rate coefficient matrix')
}
# eigenvalue/eigenvector solution
# eigenvalues and eigenvectors of coefficient matrix
eigen_matrix <- eigen(rate_coeff)
# print eigenvalues and eigenvectors
eigen_matrix$values
eigen_matrix$vectors
# separate real and imaginary parts of eigenvectors
a_real_eigenvec <- Re(eigen_matrix$vectors)
b_imag_eigenvec <- Im(eigen_matrix$vectors)
# print real and complex eigenvectors
a_real_eigenvec
b_imag_eigenvec
# separate real and imaginary parts of eigenvalues
lambda <- Re(eigen_matrix$values)
mu <- Im(eigen_matrix$values)
# print real and complex eigenvalues
lambda
mu
# initialize matrices
x_matrix_save <- vector()
u_matrix <- matrix(0, nrow = matrix_size, ncol = 1)
g_vector <- matrix(0, nrow = matrix_size, ncol = 1)
u_prime_matrix <- matrix()
u_prime_matrix_save <- matrix(0, nrow = matrix_size, ncol = 1)
fund_matrix <- matrix(0, nrow = matrix_size, ncol = matrix_size)
t = 0
## calculate fundamental matrix and inverse of fundamental matrix for 0, h, 2*h
while (t <= h*2) {
i <- 1
while (i <= matrix_size){
j <- 1
while (j <= matrix_size) {
if (mu[j] == 0) {
fund_matrix[i,j] <- exp(lambda[j]*t)*(a_real_eigenvec[i,j] * cos(mu[j]*t))
j <- j + 1
}
else {
fund_matrix[i,j] <- exp(lambda[j]*t) * (a_real_eigenvec[i,j] * cos(mu[j]*t) - b_imag_eigenvec[i,j] * sin(mu[j]*t))
j <- j + 1
fund_matrix[i,j] <- exp(lambda[j]*t) * (a_real_eigenvec[i,j] * sin(mu[j]*t) + b_imag_eigenvec[i,j] * cos(mu[j]*t))
j <- j + 1
}
}
i = i + 1
}
if (t == 0) {
t0_fund_matrix <- fund_matrix
} else if (t == h * 1) {
t1_fund_matrix <- fund_matrix
} else if (t == h * 2 ) {
t2_fund_matrix <- fund_matrix
} else {
fund_matrix <- fund_matrix
}
t = t + h
}
t0_inv_fund_matrix = solve(t0_fund_matrix, tol = tol_value)
t1_inv_fund_matrix = solve(t1_fund_matrix, tol = tol_value)
t2_inv_fund_matrix = solve(t2_fund_matrix, tol = tol_value)
## function starts here
for (t_index in seq(from = 1, to = t_index_max, by = 1)) {
g_vector[1,1] <- injection_rate[t_index]
u_prime_matrix0 <- t0_inv_fund_matrix %*% g_vector
u_prime_matrix1 <- t1_inv_fund_matrix %*% g_vector
u_prime_matrix2 <- t2_inv_fund_matrix %*% g_vector
## initial time,
## run once to get constant vector
t0_inv_fund_matrix = solve(t0_fund_matrix, tol = tol_value)
# constants for a given initial condition at t = 0
int_constants =   t0_inv_fund_matrix %*% init_condition
## Simpson's 1/3 rule for 0 to 0.2
sim_soln <- (h/3) * (u_prime_matrix0 + (4 * u_prime_matrix1) + u_prime_matrix2)
sim_soln <- matrix(sim_soln)
## u_matrix should be term by term u_prime_matrix integrated w.r.t. t and bounds 0 to time point
x_matrix = fund_matrix %*% int_constants + fund_matrix %*% sim_soln
x_matrix_save <- cbind(x_matrix_save, x_matrix)
## x_matrix solution becomes initial condition for next tau
init_condition = x_matrix
}
return(x_matrix_save)
}
}
pbpkme(10, 0.1, rate_coeff1, init_condition1, param1, 1, 0,5)
init_condition1 <- matrix(1, nrow = 2, ncol = 1)
pbpkme(10, 0.1, rate_coeff1, init_condition1, param1, 1, 0,5)
injection_rate
## needs
minute <- 160
h <- 0.05
rate_coeff1 <- matrix(0, nrow = 2, ncol = 2)
param1 <- data.frame(c((x = 4), (y = 2)))
init_condition1 <- matrix(1, nrow = 2, ncol = 1)
number_of_doses <- 1 # default - 1
start_time <- matrix(0, nrow = 1, ncol = 1)
stop_time <- matrix(0, nrow = 1, ncol = 1)
rate_coeff1[1,1] = 2*x
rate_coeff1[2,1] = -1
rate_coeff1[1,2] = 1
rate_coeff1[2,2] = y^2
pbpkme(10, 0.1, rate_coeff1, init_condition1, param1, 1, 0,5)
library(pbpkme)
?template
## needs
# minute <- 160
# h <- 0.05
# rate_coeff1 <- matrix(0, nrow = 2, ncol = 2)
# param1 <- data.frame(c((x = 4), (y = 2)))
# init_condition1 <- matrix(1, nrow = 2, ncol = 1)
# number_of_doses <- 1 # default - 1
# start_time <- matrix(0, nrow = 1, ncol = 1)
# stop_time <- matrix(0, nrow = 1, ncol = 1)
# rate_coeff1[1,1] = 2*x
# rate_coeff1[2,1] = -1
# rate_coeff1[1,2] = 1
# rate_coeff1[2,2] = y^2
#' Solve PBPK model in matrix form
#'
#' Takes in initial condition matrix (single column vector of initial concentrations) and a rate
#' coefficient matrix (flow/volume), dose profile (number of doses, start and stop time of each dose)
#' along with any parameters needed to solve the system, and outputs a matrix of the concentrations
#' in each compartment (rows) versus the time course (columns) for a given step size "h". Each column
#' represents a predicted data point at every "2*h"
#' @param start_time A vector of start times for an "i" number of doses
#' @param stop_time A vector of stop times for an "i" number of doses
#' @param number_of_doses A scalar indicating number of doses
#' @param h The step size specified for Simpson's 1/3 rule
#' @param minute The number of minutes the model will simulate out
#' @param pars A matrix of parameters defining the variables in the rate coefficient matrix and the initial conditions, if necessary
#' @param rate_coeff A matrix of rates - flow/volume corresponding to the equation (row) and concentration to be multiplied by (column)
#' @return x_matrix_save A matrix of the concentrations in each compartment (rows) versus the time course (columns) for a given step size "h". Each column represents a predicted data point at every "2*h"
#' @export
library(pbpkme)
library(pbpkme)
library(pbpkme)
R.version.string
install.packages("tidyverse")
library(tidyverse)
installr()
install.packages("installr")
library(installr)
installr()
installr()
R.version.string
library(roxygen2)
library(devtools)
install.packages("Rtools")
library("Rtools")
install.packages("rtools")
library(pbpkme)
library(pbpkme)
install.packages("Rtools")
install_github("Rtools")
writeLines('PATH="${RTOOLS40_HOME}\\usr\\bin;${PATH}"', con = "~/.Renviron")
library(pbpkme)
library(pbpkme)
